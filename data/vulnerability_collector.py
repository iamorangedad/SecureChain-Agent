#!/usr/bin/env python3
"""
智能合约漏洞案例收集器
专门收集已知的智能合约漏洞案例和攻击代码
"""

import os
import json
import time
import requests
from datetime import datetime
from typing import List, Dict, Any
import argparse
from pathlib import Path

class VulnerabilityCollector:
    def __init__(self, github_token: str = None, output_dir: str = "vulnerability_cases"):
        self.github_token = github_token
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(exist_ok=True)
        
        # GitHub API headers
        self.headers = {
            'Accept': 'application/vnd.github.v3+json',
            'User-Agent': 'VulnerabilityCollector/1.0'
        }
        if github_token:
            self.headers['Authorization'] = f'token {github_token}'
    
    def get_file_content(self, repo_owner: str, repo_name: str, file_path: str) -> str:
        """获取文件内容"""
        url = f"https://api.github.com/repos/{repo_owner}/{repo_name}/contents/{file_path}"
        
        try:
            response = requests.get(url, headers=self.headers)
            response.raise_for_status()
            data = response.json()
            
            if data.get('type') == 'file':
                import base64
                content = base64.b64decode(data['content']).decode('utf-8')
                return content
            else:
                return ""
                
        except requests.exceptions.RequestException as e:
            print(f"获取文件内容时出错: {e}")
            return ""
    
    def collect_known_vulnerabilities(self):
        """收集已知的智能合约漏洞案例"""
        print("开始收集已知的智能合约漏洞案例...")
        
        # 已知漏洞案例列表
        known_cases = [
            # Solidity 漏洞案例
            {
                "name": "DAO Hack - Reentrancy Attack",
                "repo": "slockit/DAO",
                "description": "The DAO reentrancy attack that led to the Ethereum hard fork",
                "language": "solidity",
                "files": ["contracts/DAO.sol", "contracts/TokenCreation.sol"],
                "year": 2016,
                "impact": "60M USD stolen, led to Ethereum hard fork"
            },
            {
                "name": "Parity Multi-Sig Wallet",
                "repo": "paritytech/parity",
                "description": "Parity multi-sig wallet vulnerability",
                "language": "solidity",
                "files": ["js/src/contracts/snippets/ParityWallet.sol"],
                "year": 2017,
                "impact": "150M USD frozen"
            },
            {
                "name": "BEC Token - BatchOverflow",
                "repo": "OpenZeppelin/openzeppelin-contracts",
                "description": "BatchOverflow vulnerability in BEC token",
                "language": "solidity",
                "files": ["contracts/token/ERC20/ERC20.sol"],
                "year": 2018,
                "impact": "Unlimited token minting"
            },
            {
                "name": "King of the Ether Throne",
                "repo": "kieranelby/KingOfTheEtherThrone",
                "description": "Integer overflow vulnerability",
                "language": "solidity",
                "files": ["contracts/KingOfTheEtherThrone.sol"],
                "year": 2016,
                "impact": "Integer overflow exploit"
            },
            {
                "name": "Rubixi - Dynamic Call",
                "repo": "ConsenSys/smart-contract-best-practices",
                "description": "Dynamic call vulnerability",
                "language": "solidity",
                "files": ["examples/rubixi.sol"],
                "year": 2016,
                "impact": "Access control bypass"
            },
            {
                "name": "GovernMental",
                "repo": "ConsenSys/smart-contract-best-practices",
                "description": "Timestamp dependency vulnerability",
                "language": "solidity",
                "files": ["examples/governmental.sol"],
                "year": 2015,
                "impact": "Block timestamp manipulation"
            },
            {
                "name": "Fomo3D",
                "repo": "fomo3d/fomo3d",
                "description": "Front-running and gas limit vulnerabilities",
                "language": "solidity",
                "files": ["contracts/F3D.sol", "contracts/F3Dexternal.sol"],
                "year": 2018,
                "impact": "Front-running attacks"
            },
            {
                "name": "SpankChain",
                "repo": "spankchain/payment-channel-contracts",
                "description": "Reentrancy vulnerability in payment channels",
                "language": "solidity",
                "files": ["contracts/PaymentChannel.sol"],
                "year": 2018,
                "impact": "4.2 ETH stolen"
            },
            {
                "name": "bZx Protocol",
                "repo": "bZxNetwork/bZx-monorepo",
                "description": "Flash loan attack vulnerability",
                "language": "solidity",
                "files": ["contracts/bZxProtocol.sol"],
                "year": 2020,
                "impact": "350K USD stolen"
            },
            {
                "name": "Harvest Finance",
                "repo": "harvest-finance/harvest",
                "description": "Flash loan attack",
                "language": "solidity",
                "files": ["contracts/Strategy.sol"],
                "year": 2020,
                "impact": "24M USD stolen"
            },
            {
                "name": "Cream Finance",
                "repo": "CreamFi/cream-protocol",
                "description": "Flash loan attack",
                "language": "solidity",
                "files": ["contracts/CreamToken.sol"],
                "year": 2021,
                "impact": "130M USD stolen"
            },
            {
                "name": "Poly Network",
                "repo": "poly-network/poly-contracts",
                "description": "Access control vulnerability",
                "language": "solidity",
                "files": ["contracts/PolyNetwork.sol"],
                "year": 2021,
                "impact": "600M USD stolen"
            },
            {
                "name": "Wormhole Bridge",
                "repo": "certusone/wormhole",
                "description": "Signature verification vulnerability",
                "language": "rust",
                "files": ["programs/bridge/src/lib.rs"],
                "year": 2022,
                "impact": "325M USD stolen"
            },
            {
                "name": "Ronin Bridge",
                "repo": "axieinfinity/ronin",
                "description": "Multi-signature vulnerability",
                "language": "solidity",
                "files": ["contracts/Bridge.sol"],
                "year": 2022,
                "impact": "625M USD stolen"
            },
            {
                "name": "Nomad Bridge",
                "repo": "nomad-xyz/nomad-monorepo",
                "description": "Replay attack vulnerability",
                "language": "solidity",
                "files": ["contracts/Bridge.sol"],
                "year": 2022,
                "impact": "190M USD stolen"
            },
            {
                "name": "Mango Markets",
                "repo": "blockworks-foundation/mango-v4",
                "description": "Oracle manipulation attack",
                "language": "rust",
                "files": ["programs/mango/src/lib.rs"],
                "year": 2022,
                "impact": "100M USD stolen"
            },
            {
                "name": "Wintermute",
                "repo": "gnosis/safe-contracts",
                "description": "Proxy contract vulnerability",
                "language": "solidity",
                "files": ["contracts/proxies/GnosisSafeProxy.sol"],
                "year": 2022,
                "impact": "160M USD stolen"
            },
            {
                "name": "FTX",
                "repo": "ftx/FTX",
                "description": "Backdoor vulnerability",
                "language": "solidity",
                "files": ["contracts/FTXToken.sol"],
                "year": 2022,
                "impact": "8B USD lost"
            },
            {
                "name": "Euler Finance",
                "repo": "euler-xyz/euler-contracts",
                "description": "Donate attack vulnerability",
                "language": "solidity",
                "files": ["contracts/Euler.sol"],
                "year": 2023,
                "impact": "197M USD stolen"
            },
            {
                "name": "Multichain",
                "repo": "multichain/multichain",
                "description": "Access control vulnerability",
                "language": "solidity",
                "files": ["contracts/Bridge.sol"],
                "year": 2023,
                "impact": "126M USD stolen"
            }
        ]
        
        collected_cases = []
        
        for case in known_cases:
            print(f"收集案例: {case['name']}")
            
            case_dir = self.output_dir / case['language'] / case['name'].replace(' ', '_').replace('-', '_')
            case_dir.mkdir(parents=True, exist_ok=True)
            
            case_info = {
                'name': case['name'],
                'repo': case['repo'],
                'description': case['description'],
                'language': case['language'],
                'year': case['year'],
                'impact': case['impact'],
                'files': [],
                'collected_at': datetime.now().isoformat()
            }
            
            # 尝试获取文件内容
            for file_path in case['files']:
                try:
                    repo_parts = case['repo'].split('/')
                    if len(repo_parts) == 2:
                        owner, repo_name = repo_parts
                        content = self.get_file_content(owner, repo_name, file_path)
                        
                        if content:
                            # 保存文件
                            filename = file_path.split('/')[-1]
                            file_save_path = case_dir / filename
                            
                            with open(file_save_path, 'w', encoding='utf-8') as f:
                                f.write(f"// 漏洞案例: {case['name']}\n")
                                f.write(f"// 仓库: {case['repo']}\n")
                                f.write(f"// 描述: {case['description']}\n")
                                f.write(f"// 年份: {case['year']}\n")
                                f.write(f"// 影响: {case['impact']}\n")
                                f.write(f"// 收集时间: {datetime.now().isoformat()}\n")
                                f.write("// " + "="*50 + "\n\n")
                                f.write(content)
                            
                            case_info['files'].append({
                                'path': file_path,
                                'local_path': str(file_save_path),
                                'content_length': len(content)
                            })
                            
                            print(f"  已保存: {filename}")
                        else:
                            print(f"  未找到文件: {file_path}")
                            
                except Exception as e:
                    print(f"  处理文件时出错: {e}")
                    continue
            
            collected_cases.append(case_info)
            
            # 保存案例信息
            case_metadata_file = case_dir / "case_info.json"
            with open(case_metadata_file, 'w', encoding='utf-8') as f:
                json.dump(case_info, f, indent=2, ensure_ascii=False)
        
        # 保存所有案例的元数据
        all_cases_file = self.output_dir / "all_vulnerability_cases.json"
        with open(all_cases_file, 'w', encoding='utf-8') as f:
            json.dump(collected_cases, f, indent=2, ensure_ascii=False)
        
        print(f"漏洞案例收集完成，共收集 {len(collected_cases)} 个案例")
        return collected_cases
    
    def collect_vulnerability_patterns(self):
        """收集漏洞模式代码"""
        print("开始收集漏洞模式代码...")
        
        patterns_dir = self.output_dir / "vulnerability_patterns"
        patterns_dir.mkdir(exist_ok=True)
        
        # 漏洞模式查询
        vulnerability_patterns = [
            {
                "name": "reentrancy",
                "queries": [
                    "reentrancy vulnerability solidity",
                    "call.value reentrancy",
                    "external call before state change"
                ],
                "language": "solidity"
            },
            {
                "name": "integer_overflow",
                "queries": [
                    "integer overflow solidity",
                    "uint overflow vulnerability",
                    "SafeMath overflow"
                ],
                "language": "solidity"
            },
            {
                "name": "access_control",
                "queries": [
                    "access control vulnerability",
                    "onlyOwner modifier bypass",
                    "privilege escalation"
                ],
                "language": "solidity"
            },
            {
                "name": "timestamp_dependency",
                "queries": [
                    "block.timestamp vulnerability",
                    "timestamp dependency",
                    "block timestamp manipulation"
                ],
                "language": "solidity"
            },
            {
                "name": "front_running",
                "queries": [
                    "front running vulnerability",
                    "MEV attack",
                    "sandwich attack"
                ],
                "language": "solidity"
            },
            {
                "name": "flash_loan_attack",
                "queries": [
                    "flash loan attack",
                    "flash loan exploit",
                    "flash loan vulnerability"
                ],
                "language": "solidity"
            },
            {
                "name": "oracle_manipulation",
                "queries": [
                    "oracle manipulation",
                    "price oracle attack",
                    "oracle vulnerability"
                ],
                "language": "solidity"
            },
            {
                "name": "delegatecall_vulnerability",
                "queries": [
                    "delegatecall vulnerability",
                    "delegatecall exploit",
                    "proxy delegatecall"
                ],
                "language": "solidity"
            }
        ]
        
        collected_patterns = []
        
        for pattern in vulnerability_patterns:
            print(f"收集模式: {pattern['name']}")
            
            pattern_dir = patterns_dir / pattern['language'] / pattern['name']
            pattern_dir.mkdir(parents=True, exist_ok=True)
            
            pattern_info = {
                'name': pattern['name'],
                'language': pattern['language'],
                'queries': pattern['queries'],
                'files': [],
                'collected_at': datetime.now().isoformat()
            }
            
            for query in pattern['queries']:
                try:
                    # 搜索相关代码
                    url = "https://api.github.com/search/code"
                    params = {
                        'q': query,
                        'language': pattern['language'],
                        'sort': 'indexed',
                        'order': 'desc',
                        'per_page': 10
                    }
                    
                    response = requests.get(url, headers=self.headers, params=params)
                    response.raise_for_status()
                    data = response.json()
                    
                    for result in data.get('items', []):
                        try:
                            content = self.get_file_content(
                                result['repository']['owner']['login'],
                                result['repository']['name'],
                                result['path']
                            )
                            
                            if content:
                                filename = f"{result['repository']['name']}_{result['name']}"
                                filepath = pattern_dir / filename
                                
                                with open(filepath, 'w', encoding='utf-8') as f:
                                    f.write(f"// 漏洞模式: {pattern['name']}\n")
                                    f.write(f"// 查询: {query}\n")
                                    f.write(f"// 仓库: {result['repository']['full_name']}\n")
                                    f.write(f"// 路径: {result['path']}\n")
                                    f.write(f"// URL: {result['html_url']}\n")
                                    f.write(f"// 收集时间: {datetime.now().isoformat()}\n")
                                    f.write("// " + "="*50 + "\n\n")
                                    f.write(content)
                                
                                pattern_info['files'].append({
                                    'name': result['name'],
                                    'repository': result['repository']['full_name'],
                                    'path': result['path'],
                                    'url': result['html_url'],
                                    'query': query,
                                    'local_path': str(filepath)
                                })
                                
                                print(f"  已保存: {filename}")
                                
                        except Exception as e:
                            print(f"  处理文件时出错: {e}")
                            continue
                            
                except Exception as e:
                    print(f"  搜索时出错: {e}")
                    continue
            
            collected_patterns.append(pattern_info)
            
            # 保存模式信息
            pattern_metadata_file = pattern_dir / "pattern_info.json"
            with open(pattern_metadata_file, 'w', encoding='utf-8') as f:
                json.dump(pattern_info, f, indent=2, ensure_ascii=False)
        
        # 保存所有模式的元数据
        all_patterns_file = patterns_dir / "all_patterns.json"
        with open(all_patterns_file, 'w', encoding='utf-8') as f:
            json.dump(collected_patterns, f, indent=2, ensure_ascii=False)
        
        print(f"漏洞模式收集完成，共收集 {len(collected_patterns)} 个模式")
        return collected_patterns
    
    def generate_vulnerability_report(self):
        """生成漏洞收集报告"""
        report_file = self.output_dir / "vulnerability_report.md"
        
        with open(report_file, 'w', encoding='utf-8') as f:
            f.write("# 智能合约漏洞案例收集报告\n\n")
            f.write(f"收集时间: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
            
            # 读取已知漏洞案例
            all_cases_file = self.output_dir / "all_vulnerability_cases.json"
            if all_cases_file.exists():
                with open(all_cases_file, 'r', encoding='utf-8') as cf:
                    cases = json.load(cf)
                    
                    f.write("## 已知漏洞案例\n\n")
                    f.write(f"共收集 {len(cases)} 个已知漏洞案例\n\n")
                    
                    # 按年份统计
                    year_stats = {}
                    for case in cases:
                        year = case.get('year', 'Unknown')
                        if year not in year_stats:
                            year_stats[year] = []
                        year_stats[year].append(case)
                    
                    f.write("### 按年份统计\n\n")
                    for year in sorted(year_stats.keys()):
                        f.write(f"#### {year}年 ({len(year_stats[year])}个案例)\n\n")
                        for case in year_stats[year]:
                            f.write(f"- **{case['name']}** - {case['impact']}\n")
                            f.write(f"  - 描述: {case['description']}\n")
                            f.write(f"  - 语言: {case['language']}\n")
                            f.write(f"  - 仓库: [{case['repo']}](https://github.com/{case['repo']})\n\n")
            
            # 读取漏洞模式
            patterns_file = self.output_dir / "vulnerability_patterns" / "all_patterns.json"
            if patterns_file.exists():
                with open(patterns_file, 'r', encoding='utf-8') as pf:
                    patterns = json.load(pf)
                    
                    f.write("## 漏洞模式\n\n")
                    f.write(f"共收集 {len(patterns)} 个漏洞模式\n\n")
                    
                    for pattern in patterns:
                        f.write(f"### {pattern['name']}\n")
                        f.write(f"- 语言: {pattern['language']}\n")
                        f.write(f"- 文件数: {len(pattern['files'])}\n")
                        f.write(f"- 查询: {', '.join(pattern['queries'])}\n\n")
            
            f.write("## 使用说明\n\n")
            f.write("1. `vulnerability_cases/` - 包含已知漏洞案例的代码\n")
            f.write("2. `vulnerability_patterns/` - 包含各种漏洞模式的代码\n")
            f.write("3. 每个案例/模式都有详细的元数据信息\n")
            f.write("4. 建议结合安全审计工具进行深入分析\n\n")
            
            f.write("## 安全提醒\n\n")
            f.write("- 这些代码仅用于安全研究和学习目的\n")
            f.write("- 请勿在生产环境中使用或部署这些代码\n")
            f.write("- 建议在隔离环境中进行分析\n")
            f.write("- 遵守相关法律法规和道德准则\n")
        
        print(f"漏洞报告已生成: {report_file}")
    
    def collect_all(self):
        """收集所有漏洞相关代码"""
        print("开始收集所有漏洞相关代码...")
        
        # 收集已知漏洞案例
        self.collect_known_vulnerabilities()
        
        # 收集漏洞模式
        self.collect_vulnerability_patterns()
        
        # 生成报告
        self.generate_vulnerability_report()
        
        print("所有漏洞代码收集完成！")

def main():
    parser = argparse.ArgumentParser(description='收集智能合约漏洞案例')
    parser.add_argument('--token', help='GitHub API token (可选，用于提高API限制)')
    parser.add_argument('--output', default='vulnerability_cases', help='输出目录')
    parser.add_argument('--type', choices=['cases', 'patterns', 'all'], 
                       default='all', help='要收集的类型')
    
    args = parser.parse_args()
    
    collector = VulnerabilityCollector(github_token=args.token, output_dir=args.output)
    
    if args.type == 'all':
        collector.collect_all()
    elif args.type == 'cases':
        collector.collect_known_vulnerabilities()
        collector.generate_vulnerability_report()
    elif args.type == 'patterns':
        collector.collect_vulnerability_patterns()
        collector.generate_vulnerability_report()

if __name__ == "__main__":
    main() 